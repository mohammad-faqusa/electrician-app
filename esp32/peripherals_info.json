[
  {
    "name": "accelerometer",
    "title": "Accelerometer",
    "library_name": "accelerometer",
    "class_name": "MPU6050",

    "attributes": {
      "addr": {
        "dataType": "Number",
        "format": "hex",
        "default": 104,
        "purpose": "7-bit I²C address of the sensor (0x68 default)"
      },
      "_accel_range": {
        "dataType": "Number",
        "unit": "g",
        "access": "read-only",
        "allowed": [2, 4, 8, 16],
        "purpose": "Current ±g full-scale range selected for the accelerometer"
      },
      "_gyro_range": {
        "dataType": "Number",
        "unit": "°/s",
        "access": "read-only",
        "allowed": [250, 500, 1000, 2000],
        "purpose": "Current ±deg/s full-scale range selected for the gyroscope"
      },
      "_failCount": {
        "dataType": "Number",
        "access": "read-only",
        "purpose": "Running counter of non-fatal I²C read failures"
      },
      "_terminatingFailCount": {
        "dataType": "Number",
        "access": "read-only",
        "purpose": "Counter of I²C failures that returned NaN data"
      }
    },

    "methods": {
      "read_temperature": {
        "type": "read",
        "label": "Read Temperature",
        "returns": { "dataType": "Number", "unit": "°C" },
        "purpose": "Reads and converts the on-chip thermistor value"
      },

      "set_accel_range": {
        "type": "write",
        "label": "Set Accelerometer Range",
        "parameters": [
          {
            "name": "accel_range",
            "dataType": "Number",
            "allowed": [0, 8, 16, 24],
            "map": { "0": "±2 g", "8": "±4 g", "16": "±8 g", "24": "±16 g" },
            "purpose": "Raw register value to select ±2/4/8/16 g"
          }
        ],
        "returns": { "dataType": "null" },
        "purpose": "Writes ACCEL_CONFIG to change full-scale range"
      },

      "get_accel_range": {
        "type": "read",
        "label": "Get Accelerometer Range",
        "parameters": [
          {
            "name": "raw",
            "dataType": "Boolean",
            "optional": true,
            "default": false
          }
        ],
        "returns": { "dataType": "Number", "unit": "g OR raw byte" },
        "purpose": "Fetches current ±g range (human value or raw register)"
      },

      "read_accel_data": {
        "type": "read",
        "label": "Read Accelerometer (XYZ)",
        "parameters": [
          {
            "name": "g",
            "dataType": "Boolean",
            "optional": true,
            "default": false
          }
        ],
        "returns": {
          "dataType": "Object",
          "properties": {
            "x": { "dataType": "Number" },
            "y": { "dataType": "Number" },
            "z": { "dataType": "Number" }
          },
          "unit": { "false": "m/s²", "true": "g" }
        },
        "purpose": "Reads three-axis acceleration, optionally in g units"
      },

      "read_accel_abs": {
        "type": "read",
        "label": "Read Acceleration Magnitude",
        "parameters": [
          {
            "name": "g",
            "dataType": "Boolean",
            "optional": true,
            "default": false
          }
        ],
        "returns": { "dataType": "Number", "unit": "m/s² OR g" },
        "purpose": "Scalar |a| calculated from XYZ acceleration"
      },

      "set_gyro_range": {
        "type": "write",
        "label": "Set Gyroscope Range",
        "parameters": [
          {
            "name": "gyro_range",
            "dataType": "Number",
            "allowed": [0, 8, 16, 24],
            "map": {
              "0": "±250 °/s",
              "8": "±500 °/s",
              "16": "±1000 °/s",
              "24": "±2000 °/s"
            },
            "purpose": "Raw register value to select full-scale range"
          }
        ],
        "returns": { "dataType": "null" },
        "purpose": "Writes GYRO_CONFIG to change gyroscope scale"
      },

      "get_gyro_range": {
        "type": "read",
        "label": "Get Gyroscope Range",
        "parameters": [
          {
            "name": "raw",
            "dataType": "Boolean",
            "optional": true,
            "default": false
          }
        ],
        "returns": { "dataType": "Number", "unit": "°/s OR raw byte" },
        "purpose": "Fetches current gyroscope range"
      },

      "read_gyro_data": {
        "type": "read",
        "label": "Read Gyroscope (XYZ)",
        "returns": {
          "dataType": "Object",
          "properties": {
            "x": { "dataType": "Number", "unit": "°/s" },
            "y": { "dataType": "Number", "unit": "°/s" },
            "z": { "dataType": "Number", "unit": "°/s" }
          }
        },
        "purpose": "Reads angular-velocity about X, Y, Z axes"
      },

      "read_angle": {
        "type": "read",
        "label": "Estimate Tilt Angle",
        "returns": {
          "dataType": "Object",
          "properties": {
            "x": { "dataType": "Number", "unit": "rad" },
            "y": { "dataType": "Number", "unit": "rad" }
          }
        },
        "purpose": "Quick roll/pitch estimate from accelerometer (radians)"
      }
    },

    "constructor": {
      "parameters": [
        {
          "name": "bus",
          "dataType": "Object",
          "optional": true,
          "purpose": "Pre-configured I²C bus (ignored on ESP32 preset pins)"
        },
        {
          "name": "freq",
          "dataType": "Number",
          "optional": true,
          "unit": "Hz",
          "purpose": "I²C frequency if a custom bus is supplied"
        },
        {
          "name": "sda",
          "dataType": "Pin",
          "optional": true,
          "purpose": "Alternative SDA pin (default GPIO21 on ESP32)"
        },
        {
          "name": "scl",
          "dataType": "Pin",
          "optional": true,
          "purpose": "Alternative SCL pin (default GPIO22 on ESP32)"
        },
        {
          "name": "addr",
          "dataType": "Number",
          "format": "hex",
          "default": 104,
          "purpose": "I²C address (0x68 or 0x69 when AD0 is high)"
        }
      ]
    },

    "pin_properties": {
      "vcc": { "purpose": "3 V3 / 5 V supply", "required": true },
      "gnd": { "purpose": "Ground", "required": true },
      "scl": { "purpose": "I²C clock line", "required": true },
      "sda": { "purpose": "I²C data line", "required": true },
      "int": {
        "purpose": "Interrupt output (optional for motion/overflow)",
        "required": false
      }
    }
  },
  {
    "name": "accelerometer_simulated",
    "title": "Accelerometer Simulated",
    "library_name": "accelerometer_simulated",
    "class_name": "MPU6050",
    "attributes": {
      "simulate": {
        "dataType": "Boolean",
        "default": true,
        "values_meaning": {
          "true": "Simulation mode enabled (random values returned)",
          "false": "Reads actual sensor data via I2C"
        },
        "purpose": "Determines whether the sensor operates in simulation or real hardware mode"
      },
      "addr": {
        "dataType": "Number",
        "format": "hex",
        "default": 104,
        "purpose": "I2C address of the MPU6050 sensor"
      },
      "_accel": {
        "dataType": "Array",
        "elementType": "Number",
        "length": 3,
        "unit": "g",
        "access": "read-only",
        "purpose": "Holds acceleration values on X, Y, Z axes"
      },
      "_gyro": {
        "dataType": "Array",
        "elementType": "Number",
        "length": 3,
        "unit": "deg/s",
        "access": "read-only",
        "purpose": "Holds gyroscope angular velocity values on X, Y, Z axes"
      }
    },
    "methods": {
      "read_accel": {
        "type": "read",
        "label": "Read Acceleration",
        "returns": {
          "dataType": "Array",
          "elementType": "Number",
          "length": 3,
          "unit": "g",
          "elementNames": ["x", "y", "z"],
          "range": {
            "min": -2,
            "max": 2
          }
        },
        "purpose": "Returns a tuple of X, Y, Z acceleration values"
      },
      "read_gyro": {
        "type": "read",
        "label": "Read Gyroscope",
        "returns": {
          "dataType": "Array",
          "elementType": "Number",
          "length": 3,
          "unit": "deg/s",
          "elementNames": ["x", "y", "z"],
          "range": {
            "min": -250,
            "max": 250
          }
        },
        "purpose": "Returns a tuple of X, Y, Z gyroscope values"
      },
      "read_all": {
        "type": "read",
        "label": "Read All Sensors",
        "returns": {
          "dataType": "Object",
          "properties": {
            "accel": {
              "dataType": "Array",
              "elementType": "Number",
              "length": 3,
              "unit": "g",
              "elementNames": ["x", "y", "z"],
              "range": {
                "min": -2,
                "max": 2
              }
            },
            "gyro": {
              "dataType": "Array",
              "elementType": "Number",
              "length": 3,
              "unit": "deg/s",
              "elementNames": ["x", "y", "z"],
              "range": {
                "min": -250,
                "max": 250
              }
            }
          }
        },
        "purpose": "Returns both accelerometer and gyroscope readings in one call"
      }
    },
    "constructor": {
      "parameters": [
        {
          "name": "i2c",
          "dataType": "Object",
          "default": null,
          "optional": true,
          "purpose": "I2C bus instance used to communicate with the sensor"
        },
        {
          "name": "addr",
          "dataType": "Number",
          "default": 104,
          "prefix": "hex",
          "range": {
            "min": 0,
            "max": 127
          },
          "purpose": "I2C address of the MPU6050 sensor (default is 0x68)"
        },
        {
          "name": "simulate",
          "dataType": "Boolean",
          "default": true,
          "values_meaning": {
            "true": "Simulated data (random values)",
            "false": "Real hardware readings"
          },
          "purpose": "Enables simulation mode if set to true"
        }
      ]
    },
    "pin_properties": {
      "vcc": {
        "purpose": "Power supply pin for the MPU6050 sensor (typically 3.3V or 5V)",
        "required": true
      },
      "gnd": {
        "purpose": "Ground connection for the sensor",
        "required": true
      },
      "scl": {
        "purpose": "I2C clock line used to communicate with the sensor",
        "required": true
      },
      "sda": {
        "purpose": "I2C data line used to communicate with the sensor",
        "required": true
      }
    }
  },
  {
    "name": "dht_sensor_simulated",
    "title": "DHT Sensor Simulated",
    "library_name": "dht_sensor_simulated",
    "class_name": "DHTSensor",
    "attributes": {
      "pin": {
        "dataType": "Number",
        "purpose": "GPIO pin number connected to the DHT sensor"
      },
      "sensor_type": {
        "dataType": "String",
        "default": "DHT22",
        "allowedValues": ["DHT11", "DHT22"],
        "purpose": "Specifies the type of DHT sensor being used"
      },
      "simulate": {
        "dataType": "Boolean",
        "default": true,
        "values_meaning": {
          "true": "Simulation mode enabled (random temperature and humidity values)",
          "false": "Reads actual data from the connected sensor"
        },
        "purpose": "Controls whether the sensor operates in simulation or real mode"
      },
      "_temp": {
        "dataType": "Number",
        "unit": "°C",
        "access": "read-only",
        "range": {
          "min": -40,
          "max": 125
        },
        "default": 0,
        "purpose": "Latest measured temperature value. Valid range: -40°C to 125°C"
      },
      "_humidity": {
        "dataType": "Number",
        "unit": "%",
        "access": "read-only",
        "range": {
          "min": 0,
          "max": 100
        },
        "default": 0,
        "purpose": "Latest measured humidity value. Valid range: 0% to 100%"
      }
    },
    "methods": {
      "measure": {
        "type": "write",
        "label": "Trigger Measurement",
        "returns": {
          "dataType": "void"
        },
        "purpose": "Triggers the sensor to update temperature and humidity readings"
      },
      "temperature": {
        "type": "read",
        "label": "Read Temperature",
        "returns": {
          "dataType": "Number",
          "unit": "°C",
          "range": {
            "min": -40,
            "max": 125
          }
        },
        "purpose": "Returns the last measured temperature value. Range: -40°C to 125°C"
      },
      "humidity": {
        "type": "read",
        "label": "Read Humidity",
        "returns": {
          "dataType": "Number",
          "unit": "%",
          "range": {
            "min": 0,
            "max": 100
          }
        },
        "purpose": "Returns the last measured humidity value. Range: 0% to 100%"
      }
    },
    "constructor": {
      "purpose": "Initializes the DHT sensor (DHT11 or DHT22) with the specified GPIO pin, sensor type, and simulation mode.",
      "parameters": [
        {
          "name": "pin",
          "dataType": "Number",
          "purpose": "GPIO pin number connected to the DHT sensor"
        },
        {
          "name": "sensor_type",
          "dataType": "String",
          "default": "DHT22",
          "allowedValues": ["DHT11", "DHT22"],
          "purpose": "Specifies the type of DHT sensor being used"
        },
        {
          "name": "simulate",
          "dataType": "Boolean",
          "default": true,
          "values_meaning": {
            "true": "Sensor data will be simulated using random values",
            "false": "Sensor will read actual values via GPIO"
          },
          "purpose": "Controls whether the sensor operates in simulation or real mode"
        }
      ],
      "returns": {
        "dataType": "Object",
        "class": "DHTSensor",
        "purpose": "An instance of the DHTSensor class ready for measuring temperature and humidity"
      }
    },
    "pin_properties": {
      "pin": {
        "purpose": "GPIO pin number connected to the DHT sensor",
        "required": true
      },
      "vcc": {
        "purpose": "Power supply pin for the DHT sensor",
        "required": true
      },
      "gnd": {
        "purpose": "Ground pin for the DHT sensor",
        "required": true
      }
    }
  },
  {
    "name": "dht_sensor",
    "title": "DHT Sensor",
    "library_name": "dht_sensor",
    "class_name": "DHTSensor",
    "attributes": {
      "pin": {
        "dataType": "Number",
        "purpose": "GPIO pin connected to the sensor data line"
      }
    },
    "methods": {
      "measure": {
        "type": "write",
        "label": "Trigger Measurement",
        "returns": {
          "dataType": "void"
        },
        "purpose": "Initiates a new reading cycle and refreshes the internal buffer"
      },
      "temperature": {
        "type": "read",
        "label": "Read Temperature",
        "returns": {
          "dataType": "Number",
          "unit": "°C",
          "range": {
            "min": -40,
            "max": 80
          }
        },
        "purpose": "Returns the latest temperature reading in degrees Celsius"
      },
      "humidity": {
        "type": "read",
        "label": "Read Humidity",
        "returns": {
          "dataType": "Number",
          "unit": "%",
          "range": {
            "min": 0,
            "max": 100
          }
        },
        "purpose": "Returns the latest relative-humidity reading as a percentage"
      }
    },
    "constructor": {
      "purpose": "Creates a DHTSensor instance bound to the specified GPIO pin",
      "parameters": [
        {
          "name": "pin",
          "dataType": "Number",
          "purpose": "GPIO pin number (or Pin object) where the sensor’s data line is connected"
        }
      ],
      "returns": {
        "dataType": "Object",
        "class": "DHTSensor",
        "purpose": "A ready-to-use DHTSensor object capable of measuring temperature and humidity"
      }
    },
    "pin_properties": {
      "pin": {
        "purpose": "GPIO pin connected to the sensor data line",
        "required": true
      },
      "vcc": {
        "purpose": "3.3 V or 5 V supply for the sensor",
        "required": true
      },
      "gnd": {
        "purpose": "Ground connection for the sensor",
        "required": true
      }
    }
  },

  {
    "name": "encoder",
    "title": "Encoder",
    "library_name": "encoder",
    "class_name": "Encoder",
    "attributes": {
      "pin_a": {
        "dataType": "Number",
        "purpose": "GPIO pin A for encoder signal input"
      },
      "pin_b": {
        "dataType": "Number",
        "purpose": "GPIO pin B for encoder signal input"
      },
      "simulate": {
        "dataType": "Boolean",
        "default": true,
        "values_meaning": {
          "true": "Simulation mode enabled (position manually controlled via code)",
          "false": "Reads real encoder signals from pins"
        },
        "purpose": "Determines whether encoder is in simulation or real hardware mode"
      },
      "_position": {
        "dataType": "Number",
        "access": "read-only",
        "range": {
          "min": null,
          "max": null
        },
        "default": 0,
        "purpose": "Current position of the encoder (increments/decrements on rotation)"
      }
    },
    "methods": {
      "get_position": {
        "type": "read",
        "label": "Get Position",
        "returns": {
          "dataType": "Number",
          "range": {
            "min": null,
            "max": null
          }
        },
        "purpose": "Returns the current position of the encoder"
      },
      "reset": {
        "type": "write",
        "label": "Reset Position",
        "returns": {
          "dataType": "void"
        },
        "purpose": "Resets the encoder position back to zero"
      },
      "simulate_step": {
        "type": "write",
        "label": "Simulate Step",
        "parameters": [
          {
            "name": "steps",
            "dataType": "Number",
            "range": {
              "min": -1000,
              "max": 1000
            },
            "purpose": "Number of steps to increment or decrement position (for simulate mode)"
          }
        ],
        "returns": {
          "dataType": "void"
        },
        "purpose": "Manually updates the encoder position during simulation mode",
        "availability": "Only available when simulate=true"
      }
    },
    "constructor": {
      "purpose": "Initializes the rotary encoder with two pins. Supports simulation or real hardware interrupts for position tracking.",
      "parameters": [
        {
          "name": "pin_a",
          "dataType": "Number",
          "purpose": "GPIO pin connected to encoder channel A"
        },
        {
          "name": "pin_b",
          "dataType": "Number",
          "purpose": "GPIO pin connected to encoder channel B"
        },
        {
          "name": "simulate",
          "dataType": "Boolean",
          "default": true,
          "values_meaning": {
            "true": "Enables simulation mode, position can be changed manually",
            "false": "Enables real hardware mode using interrupts on GPIO pins"
          },
          "purpose": "Controls whether the encoder operates in simulation or real mode"
        }
      ],
      "returns": {
        "dataType": "Object",
        "class": "Encoder",
        "purpose": "An instance of the Encoder class used to track rotary position"
      }
    },
    "pin_properties": {
      "gnd": {
        "purpose": "Ground connection for the encoder module",
        "required": true
      },
      "vcc": {
        "purpose": "Voltage supply for the encoder module (typically 3.3V or 5V)",
        "required": true
      },
      "s1": {
        "alias": "pin_a",
        "purpose": "Encoder signal pin A (rotational signal channel A)",
        "required": true
      },
      "s2": {
        "alias": "pin_b",
        "purpose": "Encoder signal pin B (rotational signal channel B)",
        "required": true
      },
      "key": {
        "purpose": "Push-button switch pin (optional)",
        "required": false
      }
    }
  },
  {
    "name": "gas_sensor",
    "title": "Gas Sensor",
    "library_name": "gas_sensor",
    "class_name": "GasSensor",
    "attributes": {
      "pin": {
        "dataType": "Number",
        "purpose": "GPIO pin number connected to the Gas sensor"
      },
      "analog": {
        "dataType": "Boolean",
        "default": true,
        "values_meaning": {
          "true": "Analog mode enabled (reads a range of values from 0 to 1023)",
          "false": "Digital mode enabled (reads values 0 or 1)"
        },
        "purpose": "Specifies whether the sensor is working in analog or digital mode"
      },
      "simulate": {
        "dataType": "Boolean",
        "default": true,
        "values_meaning": {
          "true": "Simulation mode enabled (random gas level values)",
          "false": "Reads actual data from the connected sensor"
        },
        "purpose": "Controls whether the sensor operates in simulation or real mode"
      },
      "_gas_level": {
        "dataType": "Number",
        "access": "read-only",
        "range": {
          "min": 0,
          "max": 1023
        },
        "default": 0,
        "purpose": "Latest gas level reading. Range: 0 to 1023 (for analog mode) or 0/1 (for digital mode)"
      }
    },
    "methods": {
      "read": {
        "type": "read",
        "label": "Read Gas Level",
        "returns": {
          "dataType": "Number",
          "range": {
            "min": 0,
            "max": 1023
          }
        },
        "purpose": "Reads the current gas level from the sensor. Range: 0 to 1023 (analog) or 0/1 (digital)"
      }
    },
    "constructor": {
      "purpose": "Initializes the gas sensor, either in simulation mode or using a real analog/digital input pin.",
      "parameters": [
        {
          "name": "pin",
          "dataType": "Number",
          "purpose": "GPIO pin number to which the gas sensor is connected"
        },
        {
          "name": "analog",
          "dataType": "Boolean",
          "default": true,
          "values_meaning": {
            "true": "Uses analog pin and ADC to read varying gas levels",
            "false": "Uses digital pin to detect gas presence (binary value)"
          },
          "purpose": "Determines if the sensor is analog or digital"
        },
        {
          "name": "simulate",
          "dataType": "Boolean",
          "default": true,
          "values_meaning": {
            "true": "Sensor values are simulated randomly",
            "false": "Reads actual values from the connected hardware"
          },
          "purpose": "Controls whether the sensor operates in simulation or real mode"
        }
      ],
      "returns": {
        "dataType": "Object",
        "class": "GasSensor",
        "purpose": "An instance of the GasSensor class ready for reading gas levels"
      }
    },
    "pin_properties": {
      "gnd": {
        "purpose": "Ground connection for the gas sensor module",
        "required": true
      },
      "vcc": {
        "purpose": "Voltage supply for the gas sensor (typically 5V or 3.3V depending on the sensor)",
        "required": true
      },
      "aout": {
        "alias": "pin",
        "purpose": "Analog output pin that provides gas concentration level (used if analog=true)",
        "required": true,
        "conditional_on": {
          "analog": true
        }
      },
      "dout": {
        "alias": "pin",
        "purpose": "Digital output pin that goes HIGH/LOW based on gas threshold (used if analog=false)",
        "required": true,
        "conditional_on": {
          "analog": false
        }
      }
    }
  },
  {
    "name": "led",
    "title": "Led",
    "library_name": "led",
    "class_name": "LED",
    "attributes": {
      "pin": {
        "dataType": "Number",
        "purpose": "GPIO pin number connected to the LED"
      },
      "active_high": {
        "dataType": "Boolean",
        "default": true,
        "values_meaning": {
          "true": "LED is turned ON when pin is high (1)",
          "false": "LED is turned ON when pin is low (0)"
        },
        "purpose": "Determines if the LED is active high or low"
      },
      "simulate": {
        "dataType": "Boolean",
        "default": true,
        "values_meaning": {
          "true": "Simulation mode enabled (LED behavior simulated)",
          "false": "Controls an actual LED on the connected GPIO pin"
        },
        "purpose": "Controls whether the LED operates in simulation or real mode"
      },
      "_state": {
        "dataType": "Boolean",
        "access": "read-only",
        "default": false,
        "values_meaning": {
          "true": "LED is ON",
          "false": "LED is OFF"
        },
        "purpose": "Tracks the current state of the LED (ON/OFF)"
      }
    },
    "methods": {
      "on": {
        "type": "write",
        "label": "Turn ON",
        "returns": {
          "dataType": "void"
        },
        "purpose": "Turns the LED ON (sets the state to ON)"
      },
      "switch": {
        "type": "write",
        "label": "Switch",
        "returns": {
          "dataType": "void"
        },
        "purpose": "Switch the led ON or OFF, according to parameter value",
        "parameters": [
          {
            "name": "status",
            "dataType": "Boolean",
            "default": false,
            "purpose": "the status boolean value, true : led on, false : led off"
          }
        ]
      },
      "off": {
        "type": "write",
        "label": "Turn OFF",
        "returns": {
          "dataType": "void"
        },
        "purpose": "Turns the LED OFF (sets the state to OFF)"
      },
      "toggle": {
        "type": "write",
        "label": "Toggle",
        "returns": {
          "dataType": "void"
        },
        "purpose": "Toggles the state of the LED (ON if OFF, OFF if ON)"
      },
      "is_on": {
        "type": "read",
        "label": "Check if ON",
        "returns": {
          "dataType": "Boolean",
          "values_meaning": {
            "true": "LED On",
            "false": "LED Off"
          }
        },
        "purpose": "Returns the current state of the LED (True if ON, False if OFF)"
      }
    },
    "constructor": {
      "purpose": "Initializes the LED object to control a digital output pin, either in simulation or hardware mode.",
      "parameters": [
        {
          "name": "pin",
          "dataType": "Number",
          "purpose": "GPIO pin number connected to the LED"
        },
        {
          "name": "active_high",
          "dataType": "Boolean",
          "default": true,
          "values_meaning": {
            "true": "LED turns ON when the GPIO pin is set HIGH",
            "false": "LED turns ON when the GPIO pin is set LOW"
          },
          "purpose": "Controls whether the LED is active-high or active-low"
        },
        {
          "name": "simulate",
          "dataType": "Boolean",
          "default": true,
          "values_meaning": {
            "true": "Simulated LED behavior (no real hardware interaction)",
            "false": "Real LED control via hardware GPIO"
          },
          "purpose": "Enables or disables simulation mode"
        }
      ],
      "returns": {
        "dataType": "Object",
        "class": "LED",
        "purpose": "An instance of the LED class ready for digital output control"
      }
    },
    "pin_properties": {
      "gnd": {
        "purpose": "Connects to ground to complete the circuit for the LED",
        "required": true
      },
      "vcc": {
        "alias": "pin",
        "purpose": "GPIO pin controlling the LED (acts as power source in active-high configuration)",
        "required": true
      }
    }
  },
  {
    "name": "internal_led",
    "title": "Internal Led",
    "library_name": "led",
    "class_name": "InternalLED",
    "inherited_from": "LED",
    "attributes": {
      "simulate": {
        "dataType": "Boolean",
        "default": false,
        "values_meaning": {
          "true": "Simulation mode enabled (LED behavior simulated)",
          "false": "Controls an actual internal LED on GPIO2"
        },
        "purpose": "Controls whether the internal LED operates in simulation or real mode"
      }
    },
    "methods": {
      "on": {
        "type": "write",
        "label": "Turn ON",
        "returns": {
          "dataType": "void"
        },
        "purpose": "Turns the LED ON (sets the state to ON)"
      },
      "switch": {
        "type": "write",
        "label": "Switch",
        "returns": {
          "dataType": "void"
        },
        "purpose": "Switch the led ON or OFF, according to parameter value",
        "parameters": [
          {
            "name": "status",
            "dataType": "Boolean",
            "default": false,
            "purpose": "the status boolean value, true : led on, false : led off"
          }
        ]
      },
      "off": {
        "type": "write",
        "label": "Turn OFF",
        "returns": {
          "dataType": "void"
        },
        "purpose": "Turns the LED OFF (sets the state to OFF)"
      },
      "toggle": {
        "type": "write",
        "label": "Toggle",
        "returns": {
          "dataType": "void"
        },
        "purpose": "Toggles the state of the LED (ON if OFF, OFF if ON)"
      },
      "is_on": {
        "type": "read",
        "label": "Check if ON",
        "returns": {
          "dataType": "Boolean",
          "values_meaning": {
            "true": "LED On",
            "false": "LED Off"
          }
        },
        "purpose": "Returns the current state of the LED (True if ON, False if OFF)"
      }
    },
    "constructor": {
      "purpose": "Initializes the internal LED, typically connected to GPIO2 on ESP32 boards. Inherits behavior from the LED base class.",
      "parameters": [
        {
          "name": "simulate",
          "dataType": "Boolean",
          "default": false,
          "values_meaning": {
            "true": "LED behavior will be simulated with print statements instead of real hardware interaction",
            "false": "Controls the actual onboard LED"
          },
          "purpose": "Determines whether the internal LED runs in simulation mode or hardware mode"
        }
      ],
      "inherits_from": "LED",
      "inherited_parameters": [
        {
          "name": "pin",
          "dataType": "Number",
          "default": 2,
          "purpose": "GPIO pin number for the internal LED (fixed to 2 for ESP32)"
        },
        {
          "name": "active_high",
          "dataType": "Boolean",
          "default": true,
          "purpose": "Indicates if the LED turns on with a HIGH signal"
        }
      ],
      "returns": {
        "dataType": "Object",
        "class": "InternalLED",
        "purpose": "An instance of InternalLED, ready to be turned on or off"
      }
    },
    "pin_properties": {
      "internal": {
        "purpose": "Uses the onboard LED (typically GPIO2) already wired inside the ESP32 board",
        "note": "No physical wiring required; LED is connected internally",
        "required": false
      }
    }
  },
  {
    "name": "motion_sensor",
    "title": "PIR Motion Sensor",
    "library_name": "motion_sensor",
    "class_name": "PIRSensor",
    "attributes": {
      "pin": {
        "dataType": "Number",
        "purpose": "GPIO pin number connected to the PIR sensor output"
      },
      "_motion_state": {
        "dataType": "Boolean",
        "access": "read-only",
        "values_meaning": {
          "true": "Motion detected (pin HIGH)",
          "false": "No motion (pin LOW)"
        },
        "purpose": "Latest sampled state of the PIR output"
      }
    },
    "methods": {
      "set_callback": {
        "type": "read",
        "label": "Register Motion Callback",
        "parameters": [
          {
            "name": "callback",
            "dataType": "Function",
            "signature": "fn(level: Boolean)",
            "purpose": "Called with true on rising edge (motion) and false on falling edge (idle)"
          }
        ],
        "returns": { "dataType": "Void" },
        "purpose": "Attach a user-supplied function to run on every edge transition"
      },
      "deinit": {
        "type": "write",
        "label": "Disable Sensor",
        "returns": { "dataType": "Void" },
        "purpose": "Detach the IRQ handler and release the GPIO"
      }
    },
    "constructor": {
      "purpose": "Create a PIRSensor edge detector and optionally register a callback.",
      "parameters": [
        {
          "name": "pin",
          "dataType": "Number",
          "purpose": "GPIO pin number connected to the PIR output"
        },
        {
          "name": "callback",
          "dataType": "Function",
          "optional": true,
          "signature": "fn(level: Boolean)",
          "purpose": "Function to call immediately on each edge (true = motion, false = idle)"
        }
      ],
      "returns": {
        "dataType": "Object",
        "class": "PIRSensor",
        "purpose": "New PIRSensor instance ready for motion detection"
      }
    }
  },
  {
    "name": "push_button",
    "title": "Push Button",
    "library_name": "push_button",
    "class_name": "PushButton",
    "attributes": {
      "pin": {
        "dataType": "Number",
        "purpose": "GPIO pin number connected to the push-button"
      },
      "debounce_ms": {
        "dataType": "Number",
        "unit": "milliseconds",
        "default": 20,
        "purpose": "Debounce interval that filters out mechanical bounce"
      }
    },
    "methods": {
      "set_callback": {
        "type": "read",
        "label": "Register Button Callback",
        "parameters": [
          {
            "name": "callback",
            "dataType": "Function",
            "signature": "fn(pressed: Boolean)",
            "purpose": "Invoked after debounce; true when pressed, false when released"
          }
        ],
        "returns": { "dataType": "Void" },
        "purpose": "Attach a user-supplied function to run on debounced state changes"
      },
      "deinit": {
        "type": "write",
        "label": "Disable Button",
        "returns": { "dataType": "Void" },
        "purpose": "Detach the IRQ handler and release the GPIO"
      }
    },
    "constructor": {
      "purpose": "Create a debounced PushButton detector and optionally register a callback.",
      "parameters": [
        {
          "name": "pin",
          "dataType": "Number",
          "purpose": "GPIO pin number connected to the button"
        },
        {
          "name": "debounce_ms",
          "dataType": "Number",
          "default": 20,
          "unit": "milliseconds",
          "purpose": "Debounce interval to ignore spurious transitions"
        },
        {
          "name": "callback",
          "dataType": "Function",
          "optional": true,
          "signature": "fn(pressed: Boolean)",
          "purpose": "Function to call after each debounced state change (true = pressed, false = released)"
        }
      ],
      "returns": {
        "dataType": "Object",
        "class": "PushButton",
        "purpose": "New PushButton instance ready for debounced edge detection"
      }
    }
  },
  {
    "name": "relay",
    "title": "Relay",
    "library_name": "relay",
    "class_name": "Relay",
    "attributes": {
      "pin": {
        "dataType": "Number",
        "purpose": "GPIO pin number connected to the Relay module"
      },
      "active_high": {
        "dataType": "Boolean",
        "default": true,
        "values_meaning": {
          "true": "Relay is active when set to HIGH",
          "false": "Relay is active when set to LOW"
        },
        "purpose": "Defines whether the relay is activated when the pin is HIGH or LOW"
      },
      "simulate": {
        "dataType": "Boolean",
        "default": true,
        "values_meaning": {
          "true": "Simulation mode enabled (manual relay state control)",
          "false": "Controls actual relay hardware connected to the pin"
        },
        "purpose": "Controls whether the relay operates in simulation or real mode"
      },
      "_state": {
        "dataType": "Boolean",
        "access": "read-only",
        "default": false,
        "values_meaning": {
          "true": "Relay is ON",
          "false": "Relay is OFF"
        },
        "purpose": "Stores the current state of the relay (ON or OFF)"
      }
    },
    "methods": {
      "on": {
        "type": "write",
        "label": "Turn On Relay",
        "returns": {
          "dataType": "void"
        },
        "purpose": "Turns the relay ON (sets pin to HIGH or LOW based on active_high)"
      },
      "off": {
        "type": "write",
        "label": "Turn Off Relay",
        "returns": {
          "dataType": "void"
        },
        "purpose": "Turns the relay OFF (sets pin to LOW or HIGH based on active_high)"
      },
      "toggle": {
        "type": "write",
        "label": "Toggle Relay State",
        "returns": {
          "dataType": "void"
        },
        "purpose": "Toggles the relay state between ON and OFF"
      },
      "is_on": {
        "type": "read",
        "label": "Check Relay State",
        "returns": {
          "dataType": "Boolean",
          "values_meaning": {
            "true": "Relay On",
            "false": "Relay Off"
          }
        },
        "purpose": "Returns the current state of the relay (True if ON, False if OFF)"
      }
    },
    "constructor": {
      "purpose": "Initializes the Relay, sets up control pin behavior and simulation mode.",
      "parameters": [
        {
          "name": "pin",
          "dataType": "Number",
          "required": true,
          "purpose": "GPIO pin number connected to the relay control input"
        },
        {
          "name": "active_high",
          "dataType": "Boolean",
          "default": true,
          "values_meaning": {
            "true": "Relay is activated when the pin is set to HIGH",
            "false": "Relay is activated when the pin is set to LOW"
          },
          "purpose": "Determines the logic level that activates the relay"
        },
        {
          "name": "simulate",
          "dataType": "Boolean",
          "default": true,
          "values_meaning": {
            "true": "Relay behavior is simulated with console output",
            "false": "Relay controls actual GPIO pin"
          },
          "purpose": "Controls whether the relay operates in simulation or real mode"
        }
      ],
      "returns": {
        "dataType": "Object",
        "class": "Relay",
        "purpose": "An instance of the Relay class ready to control relay operations"
      }
    },
    "pin_properties": {
      "gnd": {
        "purpose": "Ground connection for the relay module",
        "required": true
      },
      "vcc": {
        "purpose": "Voltage supply for the relay (typically 5V or 3.3V depending on the module)",
        "required": true
      },
      "relay_pin": {
        "alias": "pin",
        "purpose": "GPIO pin connected to the relay control input",
        "required": true
      }
    }
  },
  {
    "name": "servo_motor",
    "title": "Servo Motor",
    "library_name": "servo_motor",
    "class_name": "Servo",
    "attributes": {
      "pin": {
        "dataType": "Number",
        "purpose": "GPIO pin number connected to the Servo motor"
      },
      "freq": {
        "dataType": "Number",
        "default": 50,
        "unit": "Hz",
        "purpose": "PWM frequency for the servo signal"
      },
      "min_us": {
        "dataType": "Number",
        "default": 544,
        "unit": "μs",
        "purpose": "Minimum pulse width in microseconds (corresponds to min_deg)"
      },
      "max_us": {
        "dataType": "Number",
        "default": 2400,
        "unit": "μs",
        "purpose": "Maximum pulse width in microseconds (corresponds to max_deg)"
      },
      "min_deg": {
        "dataType": "Number",
        "default": 0,
        "unit": "°",
        "purpose": "Minimum angle in degrees"
      },
      "max_deg": {
        "dataType": "Number",
        "default": 180,
        "unit": "°",
        "purpose": "Maximum angle in degrees"
      },
      "_angle": {
        "dataType": "Number",
        "unit": "°",
        "access": "read-only",
        "purpose": "Current angle of the servo motor (in degrees)"
      },
      "_pulse_us": {
        "dataType": "Number",
        "unit": "μs",
        "access": "read-only",
        "purpose": "Current pulse width in microseconds"
      }
    },
    "methods": {
      "write": {
        "type": "write",
        "label": "Write Angle (Degrees)",
        "parameters": [
          {
            "name": "deg",
            "dataType": "Number",
            "unit": "°",
            "range": {
              "min": 0,
              "max": 180
            },
            "purpose": "Angle in degrees to move the servo to"
          }
        ],
        "returns": {
          "dataType": "void"
        },
        "purpose": "Sets the servo motor to the given angle in degrees"
      },
      "write_rad": {
        "type": "write",
        "label": "Write Angle (Radians)",
        "parameters": [
          {
            "name": "rad",
            "dataType": "Number",
            "unit": "rad",
            "purpose": "Angle in radians to move the servo to"
          }
        ],
        "returns": {
          "dataType": "void"
        },
        "purpose": "Sets the servo angle using radians"
      },
      "read": {
        "type": "read",
        "label": "Read Angle (Degrees)",
        "returns": {
          "dataType": "Number",
          "unit": "°",
          "range": {
            "min": 0,
            "max": 180
          },
          "purpose": "Returns the current angle of the servo"
        },
        "purpose": "Returns the current servo angle in degrees"
      },
      "read_rad": {
        "type": "read",
        "label": "Read Angle (Radians)",
        "returns": {
          "dataType": "Number",
          "unit": "rad",
          "purpose": "Returns the current servo angle in radians"
        },
        "purpose": "Returns the current servo angle in radians"
      },
      "write_us": {
        "type": "write",
        "label": "Write Pulse Width",
        "parameters": [
          {
            "name": "us",
            "dataType": "Number",
            "unit": "μs",
            "range": {
              "min": 544,
              "max": 2400
            },
            "purpose": "Directly sets the pulse width in microseconds"
          }
        ],
        "returns": {
          "dataType": "void"
        },
        "purpose": "Sets the pulse width directly for advanced control"
      },
      "read_us": {
        "type": "read",
        "label": "Read Pulse Width",
        "returns": {
          "dataType": "Number",
          "unit": "μs",
          "range": {
            "min": 544,
            "max": 2400
          },
          "purpose": "Returns the current pulse width in microseconds"
        },
        "purpose": "Returns the pulse width currently sent to the servo"
      },
      "off": {
        "type": "write",
        "label": "Turn Off",
        "returns": {
          "dataType": "void"
        },
        "purpose": "Turns off the PWM signal to the servo"
      }
    },
    "constructor": {
      "purpose": "Initializes a Servo motor using PWM on a specified pin and angle-to-pulse mapping.",
      "parameters": [
        {
          "name": "pin_id",
          "dataType": "Number",
          "purpose": "GPIO pin number connected to the servo signal wire"
        },
        {
          "name": "min_us",
          "dataType": "Number",
          "default": 544,
          "unit": "μs",
          "purpose": "Minimum pulse width in microseconds for min_deg"
        },
        {
          "name": "max_us",
          "dataType": "Number",
          "default": 2400,
          "unit": "μs",
          "purpose": "Maximum pulse width in microseconds for max_deg"
        },
        {
          "name": "min_deg",
          "dataType": "Number",
          "default": 0,
          "unit": "°",
          "purpose": "Minimum angle in degrees (default 0°)"
        },
        {
          "name": "max_deg",
          "dataType": "Number",
          "default": 180,
          "unit": "°",
          "purpose": "Maximum angle in degrees (default 180°)"
        },
        {
          "name": "freq",
          "dataType": "Number",
          "default": 50,
          "unit": "Hz",
          "purpose": "PWM frequency for controlling the servo (default 50Hz)"
        }
      ],
      "returns": {
        "dataType": "Object",
        "class": "Servo",
        "purpose": "An instance of the Servo class ready for angle or pulse control"
      }
    },
    "pin_properties": {
      "gnd": {
        "purpose": "Ground connection for the servo motor",
        "required": true
      },
      "vcc": {
        "purpose": "Voltage supply for the servo motor (typically 5V or 3.3V depending on the model)",
        "required": true
      },
      "signal": {
        "alias": "pin",
        "purpose": "GPIO pin number connected to the servo signal wire",
        "required": true
      }
    }
  },
  {
    "name": "slide_switch",
    "title": "Slide Switch",
    "library_name": "slide_switch",
    "class_name": "SlideSwitch",
    "attributes": {
      "pin": {
        "dataType": "Number",
        "purpose": "GPIO pin number connected to the slide switch"
      },
      "simulate": {
        "dataType": "Boolean",
        "default": true,
        "values_meaning": {
          "true": "Simulation mode enabled (state is manually set)",
          "false": "Reads actual hardware pin state"
        },
        "purpose": "Controls whether the switch operates in simulation or real mode"
      },
      "_state": {
        "dataType": "Boolean",
        "default": false,
        "access": "read-write",
        "values_meaning": {
          "true": "Switch is ON",
          "false": "Switch is OFF"
        },
        "purpose": "Internal switch state when in simulation mode"
      }
    },
    "methods": {
      "set_simulated_state": {
        "type": "write",
        "label": "Set Simulated State",
        "parameters": [
          {
            "name": "state",
            "dataType": "Boolean",
            "values_meaning": {
              "true": "Simulates turning the switch ON",
              "false": "Simulates turning the switch OFF"
            },
            "purpose": "Controls the simulated state of the switch"
          }
        ],
        "returns": {
          "dataType": "void"
        },
        "purpose": "Sets the internal state of the switch during simulation"
      },
      "read": {
        "type": "read",
        "label": "Read Switch State",
        "returns": {
          "dataType": "Boolean",
          "values_meaning": {
            "true": "Switch is ON",
            "false": "Switch is OFF"
          }
        },
        "purpose": "Reads the current switch state (either simulated or from the actual pin)"
      },
      "state": {
        "type": "read",
        "label": "State Alias",
        "returns": {
          "dataType": "Boolean",
          "values_meaning": {
            "true": "Switch is ON",
            "false": "Switch is OFF"
          }
        },
        "purpose": "Property alias for reading the switch state"
      }
    },
    "constructor": {
      "purpose": "Initializes the SlideSwitch on the given GPIO pin. Can operate in real or simulated mode.",
      "parameters": [
        {
          "name": "pin",
          "dataType": "Number",
          "purpose": "GPIO pin number to which the slide switch is connected"
        },
        {
          "name": "simulate",
          "dataType": "Boolean",
          "default": true,
          "values_meaning": {
            "true": "Simulated mode enabled; state changes can be simulated programmatically",
            "false": "Reads the actual hardware state of the slide switch"
          },
          "purpose": "Determines whether the switch operates in simulation or real hardware mode"
        }
      ],
      "returns": {
        "dataType": "Object",
        "class": "SlideSwitch",
        "purpose": "An instance of the SlideSwitch class ready for use"
      }
    },
    "pin_properties": {
      "gnd": {
        "purpose": "Ground connection for the slide switch",
        "required": true
      },
      "vcc": {
        "purpose": "Voltage supply for the slide switch (typically 3.3V or 5V depending on the model)",
        "required": true
      },
      "signal": {
        "alias": "pin",
        "purpose": "GPIO pin number connected to the slide switch",
        "required": true
      }
    }
  }
]
